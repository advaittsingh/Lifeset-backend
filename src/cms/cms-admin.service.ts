import { Injectable, BadRequestException, NotFoundException, ConflictException, InternalServerErrorException, Logger } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { countWords, countPlainTextCharacters } from '../common/utils/validation.helpers';
import { updateCategoryPostCount } from '../common/utils/category.helpers';
import { Prisma } from '@prisma/client';

@Injectable()
export class CmsAdminService {
  private readonly logger = new Logger(CmsAdminService.name);
  
  constructor(private prisma: PrismaService) {}

  // ========== Current Affairs & General Knowledge ==========
  async getCurrentAffairs(filters?: any) {
    const where: any = { postType: 'CURRENT_AFFAIRS' };
    if (filters?.category) where.categoryId = filters.category;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    // Default to showing only active posts unless explicitly filtered
    if (filters?.isActive !== undefined) {
      where.isActive = filters.isActive === 'true';
    } else {
      where.isActive = true; // Default: only show active (non-deleted) posts
    }

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async createCurrentAffair(data: any, userId: string) {
    // Set isActive based on isPublished: if published, make it active immediately
    const isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    
    // No word limit validation - description can be any length
    // HTML tags are preserved in the description field
    
    // Create the post with basic fields
    const post = await this.prisma.post.create({
      data: {
        userId,
        title: data.title,
        description: data.description,
        postType: 'CURRENT_AFFAIRS',
        categoryId: data.categoryId,
        images: data.images || [],
        isActive,
        // Store additional fields in metadata
        metadata: {
          language: data.language,
          isPublished: data.isPublished,
          fullArticle: data.fullArticle,
          articleCategory: data.articleCategory,
          subCategoryId: data.subCategoryId,
          subCategory: data.subCategory,
          chapterId: data.chapterId,
          section: data.section,
          country: data.country,
          headline: data.headline,
          quickViewContent: data.quickViewContent,
          targetedKeywords: data.targetedKeywords,
          autoGeneratedKeywords: data.autoGeneratedKeywords,
          articleDate: data.articleDate,
          eventDates: data.eventDates ? JSON.parse(JSON.stringify(data.eventDates)) : [],
          eventYearRange: data.eventYearRange,
          locationLat: data.locationLat,
          locationLong: data.locationLong,
          state: data.state,
          district: data.district,
          city: data.city,
          sendNotification: data.sendNotification,
          notificationTime: data.notificationTime,
          articleType: data.articleType,
        },
      },
    });

    return post;
  }

  async getCurrentAffairById(id: string) {
    const post = await this.prisma.post.findUnique({
      where: { id, postType: 'CURRENT_AFFAIRS' },
      include: { 
        user: true, 
        category: true,
      },
    });

    if (!post) {
      throw new NotFoundException('Current affair not found');
    }

    // Return post with metadata fields extracted
    const metadata = post.metadata as any || {};
    return {
      ...post,
      isPublished: metadata.isPublished !== undefined ? metadata.isPublished : post.isActive,
    };
  }

  async updateCurrentAffair(id: string, data: any) {
    // Get existing post to preserve metadata
    const existingPost = await this.prisma.post.findUnique({
      where: { id },
      select: { metadata: true },
    });

    const existingMetadata = (existingPost?.metadata as any) || {};

    // Update isActive based on isPublished if provided
    const updateData: any = {
      title: data.title,
      description: data.description,
      categoryId: data.categoryId,
      images: data.images,
      isActive: data.isActive,
      // Store article fields in metadata
      metadata: {
        ...existingMetadata,
        language: data.language !== undefined ? data.language : existingMetadata.language,
        isPublished: data.isPublished !== undefined ? data.isPublished : existingMetadata.isPublished,
        fullArticle: data.fullArticle !== undefined ? data.fullArticle : existingMetadata.fullArticle,
        articleCategory: data.articleCategory !== undefined ? data.articleCategory : existingMetadata.articleCategory,
        subCategoryId: data.subCategoryId !== undefined ? data.subCategoryId : existingMetadata.subCategoryId,
        subCategory: data.subCategory !== undefined ? data.subCategory : existingMetadata.subCategory,
        chapterId: data.chapterId !== undefined ? data.chapterId : existingMetadata.chapterId,
        section: data.section !== undefined ? data.section : existingMetadata.section,
        country: data.country !== undefined ? data.country : existingMetadata.country,
        headline: data.headline !== undefined ? data.headline : existingMetadata.headline,
        quickViewContent: data.quickViewContent !== undefined ? data.quickViewContent : existingMetadata.quickViewContent,
        targetedKeywords: data.targetedKeywords !== undefined ? data.targetedKeywords : existingMetadata.targetedKeywords,
        autoGeneratedKeywords: data.autoGeneratedKeywords !== undefined ? data.autoGeneratedKeywords : existingMetadata.autoGeneratedKeywords,
        articleDate: data.articleDate !== undefined ? data.articleDate : existingMetadata.articleDate,
        eventDates: data.eventDates !== undefined ? JSON.parse(JSON.stringify(data.eventDates)) : existingMetadata.eventDates,
        eventYearRange: data.eventYearRange !== undefined ? data.eventYearRange : existingMetadata.eventYearRange,
        locationLat: data.locationLat !== undefined ? data.locationLat : existingMetadata.locationLat,
        locationLong: data.locationLong !== undefined ? data.locationLong : existingMetadata.locationLong,
        state: data.state !== undefined ? data.state : existingMetadata.state,
        district: data.district !== undefined ? data.district : existingMetadata.district,
        city: data.city !== undefined ? data.city : existingMetadata.city,
        sendNotification: data.sendNotification !== undefined ? data.sendNotification : existingMetadata.sendNotification,
        notificationTime: data.notificationTime !== undefined ? data.notificationTime : existingMetadata.notificationTime,
        articleType: data.articleType !== undefined ? data.articleType : existingMetadata.articleType,
      },
    };

    // Remove undefined fields
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined) {
        delete updateData[key];
      }
    });

    // Set isActive based on isPublished if provided
    if (data.isPublished !== undefined) {
      updateData.isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    }

    return this.prisma.post.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteCurrentAffair(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== General Knowledge ==========
  async getGeneralKnowledge(filters?: any) {
    const where: any = { 
      postType: 'COLLEGE_FEED',
      // Note: articleType filtering removed - all COLLEGE_FEED posts are returned
      // Filtering by articleType in metadata would require raw SQL
    };
    if (filters?.category) where.categoryId = filters.category;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    // Default to showing only active posts unless explicitly filtered
    if (filters?.isActive !== undefined) {
      where.isActive = filters.isActive === 'true';
    } else {
      where.isActive = true; // Default: only show active (non-deleted) posts
    }

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async getGeneralKnowledgeById(id: string) {
    const post = await this.prisma.post.findFirst({
      where: { 
        id,
        postType: 'COLLEGE_FEED',
        // Note: articleType filtering removed
      },
      include: { 
        user: true, 
        category: true,
      },
    });

    if (!post) {
      throw new NotFoundException('General knowledge article not found');
    }

    // Return post with metadata fields extracted
    const metadata = post.metadata as any || {};
    return {
      ...post,
      isPublished: metadata.isPublished !== undefined ? metadata.isPublished : post.isActive,
    };
  }

  async createGeneralKnowledge(data: any, userId: string) {
    // Set isActive based on isPublished: if published, make it active immediately
    const isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    
    // No word limit validation - description can be any length
    // HTML tags are preserved in the description field
    
    // Create the post with basic fields
    const post = await this.prisma.post.create({
      data: {
        userId,
        title: data.title,
        description: data.description,
        postType: 'COLLEGE_FEED',
        categoryId: data.categoryId,
        images: data.images || [],
        isActive,
        // Store additional fields in metadata
        metadata: {
          language: data.language,
          isPublished: data.isPublished,
          fullArticle: data.fullArticle,
          articleCategory: data.articleCategory,
          subCategoryId: data.subCategoryId,
          subCategory: data.subCategory,
          chapterId: data.chapterId,
          section: data.section,
          country: data.country,
          headline: data.headline,
          quickViewContent: data.quickViewContent,
          targetedKeywords: data.targetedKeywords,
          autoGeneratedKeywords: data.autoGeneratedKeywords,
          articleDate: data.articleDate,
          eventDates: data.eventDates ? JSON.parse(JSON.stringify(data.eventDates)) : [],
          eventYearRange: data.eventYearRange,
          locationLat: data.locationLat,
          locationLong: data.locationLong,
          state: data.state,
          district: data.district,
          city: data.city,
          sendNotification: data.sendNotification,
          notificationTime: data.notificationTime,
          articleType: 'GENERAL_KNOWLEDGE', // Set articleType for GK articles
        },
      },
    });

    return post;
  }

  async updateGeneralKnowledge(id: string, data: any) {
    // Get existing post to preserve metadata
    const existingPost = await this.prisma.post.findUnique({
      where: { id },
      select: { metadata: true },
    });

    const existingMetadata = (existingPost?.metadata as any) || {};

    // Update isActive based on isPublished if provided
    const updateData: any = {
      title: data.title,
      description: data.description,
      categoryId: data.categoryId,
      images: data.images,
      isActive: data.isActive,
      // Store article fields in metadata
      metadata: {
        ...existingMetadata,
        language: data.language !== undefined ? data.language : existingMetadata.language,
        isPublished: data.isPublished !== undefined ? data.isPublished : existingMetadata.isPublished,
        fullArticle: data.fullArticle !== undefined ? data.fullArticle : existingMetadata.fullArticle,
        articleCategory: data.articleCategory !== undefined ? data.articleCategory : existingMetadata.articleCategory,
        subCategoryId: data.subCategoryId !== undefined ? data.subCategoryId : existingMetadata.subCategoryId,
        subCategory: data.subCategory !== undefined ? data.subCategory : existingMetadata.subCategory,
        chapterId: data.chapterId !== undefined ? data.chapterId : existingMetadata.chapterId,
        section: data.section !== undefined ? data.section : existingMetadata.section,
        country: data.country !== undefined ? data.country : existingMetadata.country,
        headline: data.headline !== undefined ? data.headline : existingMetadata.headline,
        quickViewContent: data.quickViewContent !== undefined ? data.quickViewContent : existingMetadata.quickViewContent,
        targetedKeywords: data.targetedKeywords !== undefined ? data.targetedKeywords : existingMetadata.targetedKeywords,
        autoGeneratedKeywords: data.autoGeneratedKeywords !== undefined ? data.autoGeneratedKeywords : existingMetadata.autoGeneratedKeywords,
        articleDate: data.articleDate !== undefined ? data.articleDate : existingMetadata.articleDate,
        eventDates: data.eventDates !== undefined ? JSON.parse(JSON.stringify(data.eventDates)) : existingMetadata.eventDates,
        eventYearRange: data.eventYearRange !== undefined ? data.eventYearRange : existingMetadata.eventYearRange,
        locationLat: data.locationLat !== undefined ? data.locationLat : existingMetadata.locationLat,
        locationLong: data.locationLong !== undefined ? data.locationLong : existingMetadata.locationLong,
        state: data.state !== undefined ? data.state : existingMetadata.state,
        district: data.district !== undefined ? data.district : existingMetadata.district,
        city: data.city !== undefined ? data.city : existingMetadata.city,
        sendNotification: data.sendNotification !== undefined ? data.sendNotification : existingMetadata.sendNotification,
        notificationTime: data.notificationTime !== undefined ? data.notificationTime : existingMetadata.notificationTime,
        articleType: data.articleType !== undefined ? data.articleType : (existingMetadata.articleType || 'GENERAL_KNOWLEDGE'),
      },
    };

    // Remove undefined fields
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined) {
        delete updateData[key];
      }
    });

    // Set isActive based on isPublished if provided
    if (data.isPublished !== undefined) {
      updateData.isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    }

    return this.prisma.post.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteGeneralKnowledge(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== MCQ Management ==========
  async getMcqQuestions(filters?: any) {
    try {
      const where: any = {};
      if (filters?.categoryId) where.categoryId = filters.categoryId;
      if (filters?.articleId) where.articleId = filters.articleId; // Support filtering by articleId
      if (filters?.search) {
        where.OR = [
          { question: { contains: filters.search, mode: 'insensitive' } },
        ];
      }

      const page = parseInt(String(filters?.page || 1), 10);
      const limit = parseInt(String(filters?.limit || 20), 10);
      const skip = (page - 1) * limit;

      const [questions, total] = await Promise.all([
        this.prisma.mcqQuestion.findMany({
          where,
          include: { 
            category: true, // Include WallCategory relation
          },
          orderBy: { createdAt: 'desc' },
          skip,
          take: limit,
        }),
        this.prisma.mcqQuestion.count({ where }),
      ]);

      // Filter out questions with null categories (invalid categoryId)
      // Note: category relation is optional, so some questions might have null categories
      const validQuestions = questions.filter(q => q.category !== null);

      // Count total valid questions by getting all valid categoryIds first
      // Then count questions that have those categoryIds
      let totalValid = total;
      try {
        // Get all valid WallCategory IDs
        const validCategoryIds = await this.prisma.wallCategory.findMany({
          where: { isActive: true },
          select: { id: true },
        });
        const validCategoryIdSet = new Set(validCategoryIds.map(c => c.id));

        // Count questions with valid categoryIds
        totalValid = await this.prisma.mcqQuestion.count({
          where: {
            ...where,
            categoryId: { in: Array.from(validCategoryIdSet) },
          },
        });
      } catch (countError: any) {
        this.logger.warn(`Error counting valid questions, using total count: ${countError.message}`);
        // Fallback to total count if counting fails
        totalValid = total;
      }

      this.logger.log(`Found ${validQuestions.length} valid MCQ questions on page ${page} (${questions.length - validQuestions.length} with invalid categories)`);
      this.logger.log(`Total valid questions in database: ${totalValid}`);

      return {
        data: validQuestions,
        pagination: {
          page,
          limit,
          total: totalValid, // Return total count of valid questions across all pages
          totalPages: Math.ceil(totalValid / limit),
        },
      };
    } catch (error: any) {
      this.logger.error(`Error fetching MCQ questions: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to fetch MCQ questions: ${error.message}`);
    }
  }

  async getMcqQuestionById(id: string) {
    try {
      const question = await this.prisma.mcqQuestion.findUnique({
        where: { id },
        include: {
          category: true, // Include WallCategory relation
        },
      });

      if (!question) {
        throw new NotFoundException(`MCQ question with ID ${id} not found`);
      }

      // Check if category is null (invalid categoryId)
      if (!question.category) {
        this.logger.warn(`MCQ question ${id} has invalid categoryId: ${question.categoryId}`);
      }

      return question;
    } catch (error: any) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Error fetching MCQ question ${id}: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to fetch MCQ question: ${error.message}`);
    }
  }

  async createMcqQuestion(data: any) {
    // Validate categoryId is provided (required field)
    if (!data.categoryId) {
      throw new BadRequestException('categoryId is required for MCQ questions');
    }

    // Create MCQ with all fields as columns
    this.logger.log(`Creating MCQ question with data: ${JSON.stringify({
      question: data.question?.substring(0, 50),
      categoryId: data.categoryId,
      questionImage: data.questionImage ? 'present' : 'missing',
      explanationImage: data.explanationImage ? 'present' : 'missing',
    })}`);

    return this.prisma.mcqQuestion.create({
      data: {
        question: data.question,
        options: data.options,
        correctAnswer: data.correctAnswer,
        categoryId: data.categoryId,
        explanation: data.explanation,
        solution: data.solution,
        difficulty: data.difficulty || 'medium',
        tags: data.tags || [],
        articleId: data.articleId || null,
        questionImage: data.questionImage || null,
        explanationImage: data.explanationImage || null,
        language: data.language || 'ENGLISH',
      },
    });
  }

  async updateMcqQuestion(id: string, data: any) {
    this.logger.log(`Updating MCQ question ${id} with data: ${JSON.stringify({
      questionImage: data.questionImage ? 'present' : 'missing',
      explanationImage: data.explanationImage ? 'present' : 'missing',
    })}`);

    // Build update data object, only including fields that are provided
    const updateData: any = {};
    
    if (data.question !== undefined) updateData.question = data.question;
    if (data.options !== undefined) updateData.options = data.options;
    if (data.correctAnswer !== undefined) updateData.correctAnswer = data.correctAnswer;
    if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;
    if (data.explanation !== undefined) updateData.explanation = data.explanation;
    if (data.solution !== undefined) updateData.solution = data.solution;
    if (data.difficulty !== undefined) updateData.difficulty = data.difficulty;
    if (data.tags !== undefined) updateData.tags = data.tags;
    if (data.articleId !== undefined) updateData.articleId = data.articleId;
    if (data.questionImage !== undefined) updateData.questionImage = data.questionImage;
    if (data.explanationImage !== undefined) updateData.explanationImage = data.explanationImage;
    if (data.language !== undefined) updateData.language = data.language;

    return this.prisma.mcqQuestion.update({ 
      where: { id }, 
      data: updateData 
    });
  }

  async deleteMcqQuestion(id: string) {
    return this.prisma.mcqQuestion.delete({ where: { id } });
  }

  async getMcqCategories() {
    // MCQ questions now use WallCategory instead of McqCategory
    // Return wall categories that can be used for MCQ
    return this.prisma.wallCategory.findMany({ 
      where: { isActive: true },
      orderBy: { name: 'asc' } 
    });
  }

  async createMcqCategory(data: any) {
    // MCQ questions now use WallCategory instead of McqCategory
    // Create a wall category for MCQ use
    return this.prisma.wallCategory.create({ 
      data: {
        ...data,
        categoryFor: 'MCQ', // Mark as MCQ category
      }
    });
  }

  // ========== Know Yourself (Personality Quiz) ==========
  async getPersonalityQuestions(filters?: { isPublished?: boolean; includeInactive?: boolean | string }) {
    try {
      // Handle includeInactive parameter (can be boolean or string from query params)
      let includeInactive = false;
      if (filters?.includeInactive !== undefined) {
        if (typeof filters.includeInactive === 'boolean') {
          includeInactive = filters.includeInactive;
        } else if (typeof filters.includeInactive === 'string') {
          includeInactive = filters.includeInactive.toLowerCase() === 'true';
        }
      }
      
      // Build where clause - always include at least isActive filter for consistency
      const where: any = includeInactive ? {} : { isActive: true };
      
      // Note: PersonalityQuiz doesn't have isPublished field
      // If frontend sends isPublished filter, we ignore it
      
      // Execute query with error handling
      let questions;
      try {
        // First, try to get all questions without orderBy to avoid null order issues
        questions = await this.prisma.personalityQuiz.findMany({
          where,
        });
        
        // Manually sort: questions by order (ascending), with createdAt as secondary sort
        // Handle potential null/undefined orders (defensive programming for data inconsistencies)
        questions = questions.sort((a, b) => {
          const aOrder = a.order ?? Number.MAX_SAFE_INTEGER; // Put null/undefined at end
          const bOrder = b.order ?? Number.MAX_SAFE_INTEGER;
          
          if (aOrder !== bOrder) {
            return aOrder - bOrder;
          }
          // If order is same, sort by createdAt
          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
        });
        
        this.logger.log(`✅ Successfully fetched ${questions.length} personality quiz questions (includeInactive: ${includeInactive})`);
      } catch (dbError: any) {
        this.logger.error(`❌ Database error fetching personality questions: ${dbError.message}`, dbError.stack);
        throw new InternalServerErrorException(
          `Failed to fetch personality questions: ${dbError.message}. Please check database connection.`
        );
      }
      
      // Return questions array directly (frontend expects array)
      return questions || [];
    } catch (error: any) {
      this.logger.error(`❌ Error fetching personality quiz questions: ${error.message}`, error.stack);
      
      // If it's already an HttpException, re-throw it
      if (error instanceof BadRequestException || 
          error instanceof NotFoundException || 
          error instanceof ConflictException ||
          error instanceof InternalServerErrorException) {
        throw error;
      }
      
      // Convert unknown errors to InternalServerErrorException with safe message
      throw new InternalServerErrorException(
        `Failed to fetch personality questions: ${error.message || 'Unknown error'}. Please try again or contact support.`
      );
    }
  }

  async createPersonalityQuestion(data: any) {
    // Extract isPublished and set default if not provided
    const { isPublished = false, ...questionData } = data;
    
    return this.prisma.personalityQuiz.create({
      data: {
        ...questionData,
        isPublished,
      },
    });
  }

  async updatePersonalityQuestion(id: string, data: any) {
    // isPublished can be updated along with other fields
    return this.prisma.personalityQuiz.update({ 
      where: { id }, 
      data 
    });
  }

  async deletePersonalityQuestion(id: string) {
    return this.prisma.personalityQuiz.update({ where: { id }, data: { isActive: false } });
  }

  // ========== Daily Digest ==========
  async getDailyDigests(filters?: any) {
    const where: any = { postType: 'DIGEST' };
    if (filters?.date) where.date = new Date(filters.date);
    if (filters?.isPublished !== undefined) where.isPublished = filters.isPublished === 'true';

    return this.prisma.post.findMany({
      where,
      include: { user: true },
      orderBy: { createdAt: 'desc' },
    });
  }

  async createDailyDigest(data: any, userId: string) {
    return this.prisma.post.create({
      data: {
        ...data,
        userId,
        postType: 'DIGEST',
      },
    });
  }

  // ========== College Events ==========
  async getCollegeEvents(filters?: any) {
    const where: any = { postType: 'EVENT' };
    if (filters?.collegeId) where.user = { collegeProfile: { id: filters.collegeId } };
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: { user: { include: { collegeProfile: true } } },
      orderBy: { createdAt: 'desc' },
    });
  }

  async createCollegeEvent(data: any, userId: string) {
    return this.prisma.post.create({
      data: {
        ...data,
        userId,
        postType: 'EVENT',
      },
    });
  }

  // ========== Govt Vacancies ==========
  async getGovtVacancies(filters?: any) {
    const where: any = { postType: 'GOVT_JOB' };
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    // Default to showing only active posts unless explicitly filtered
    if (filters?.isActive !== undefined) {
      where.isActive = filters.isActive === 'true';
    } else {
      where.isActive = true;
    }

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async createGovtVacancy(data: any, userId: string) {
    const isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    
    const post = await this.prisma.post.create({
      data: {
        userId,
        title: data.nameOfPost || data.title,
        description: data.description,
        postType: 'GOVT_JOB',
        categoryId: data.mainCourseCategoryId || data.categoryId,
        images: data.images || data.organisationImage ? [data.organisationImage || data.images?.[0]] : [],
        isActive,
        metadata: {
          contentLanguage: data.contentLanguage,
          mainCourseCategoryId: data.mainCourseCategoryId,
          awardCategoryId: data.awardCategoryId,
          specialisationCategoryId: data.specialisationCategoryId,
          examLevel: data.examLevel,
          examName: data.examName,
          organisationImage: data.organisationImage || data.images?.[0],
          nameOfPost: data.nameOfPost,
          firstAnnouncementDate: data.firstAnnouncementDate,
          applicationSubmissionLastDate: data.applicationSubmissionLastDate,
          examDate: data.examDate,
          examFees: data.examFees,
          vacanciesSeat: data.vacanciesSeat,
          evaluationExamPattern: data.evaluationExamPattern,
          cutoff: data.cutoff,
          eligibility: data.eligibility,
          ageLimit: data.ageLimit,
          isPublished: data.isPublished,
        },
      },
    });

    return post;
  }

  async getGovtVacancyById(id: string) {
    const post = await this.prisma.post.findUnique({
      where: { id, postType: 'GOVT_JOB' },
      include: { 
        user: true, 
        category: true,
      },
    });

    if (!post) {
      throw new NotFoundException('Government vacancy not found');
    }

    // Return post with metadata fields extracted
    const metadata = post.metadata as any || {};
    return {
      ...post,
      isPublished: metadata.isPublished !== undefined ? metadata.isPublished : post.isActive,
      contentLanguage: metadata.contentLanguage,
      mainCourseCategoryId: metadata.mainCourseCategoryId,
      awardCategoryId: metadata.awardCategoryId,
      specialisationCategoryId: metadata.specialisationCategoryId,
      examLevel: metadata.examLevel,
      examName: metadata.examName,
      organisationImageUrl: metadata.organisationImage,
      organisationImage: metadata.organisationImage,
      nameOfPost: metadata.nameOfPost || post.title,
      firstAnnouncementDate: metadata.firstAnnouncementDate,
      applicationSubmissionLastDate: metadata.applicationSubmissionLastDate,
      examDate: metadata.examDate,
      examFees: metadata.examFees,
      vacanciesSeat: metadata.vacanciesSeat,
      evaluationExamPattern: metadata.evaluationExamPattern,
      cutoff: metadata.cutoff,
      eligibility: metadata.eligibility,
      ageLimit: metadata.ageLimit,
    };
  }

  async updateGovtVacancy(id: string, data: any) {
    const existingPost = await this.prisma.post.findUnique({
      where: { id },
      select: { metadata: true },
    });

    if (!existingPost) {
      throw new NotFoundException('Government vacancy not found');
    }

    const existingMetadata = (existingPost?.metadata as any) || {};
    const imageUrl = data.organisationImage || data.images?.[0];

    const updateData: any = {
      title: data.nameOfPost || data.title,
      description: data.description,
      categoryId: data.mainCourseCategoryId || data.categoryId,
      images: imageUrl ? [imageUrl] : data.images,
      isActive: data.isActive,
      metadata: {
        ...existingMetadata,
        contentLanguage: data.contentLanguage !== undefined ? data.contentLanguage : existingMetadata.contentLanguage,
        mainCourseCategoryId: data.mainCourseCategoryId !== undefined ? data.mainCourseCategoryId : existingMetadata.mainCourseCategoryId,
        awardCategoryId: data.awardCategoryId !== undefined ? data.awardCategoryId : existingMetadata.awardCategoryId,
        specialisationCategoryId: data.specialisationCategoryId !== undefined ? data.specialisationCategoryId : existingMetadata.specialisationCategoryId,
        examLevel: data.examLevel !== undefined ? data.examLevel : existingMetadata.examLevel,
        examName: data.examName !== undefined ? data.examName : existingMetadata.examName,
        organisationImage: imageUrl || existingMetadata.organisationImage,
        nameOfPost: data.nameOfPost !== undefined ? data.nameOfPost : existingMetadata.nameOfPost,
        firstAnnouncementDate: data.firstAnnouncementDate !== undefined ? data.firstAnnouncementDate : existingMetadata.firstAnnouncementDate,
        applicationSubmissionLastDate: data.applicationSubmissionLastDate !== undefined ? data.applicationSubmissionLastDate : existingMetadata.applicationSubmissionLastDate,
        examDate: data.examDate !== undefined ? data.examDate : existingMetadata.examDate,
        examFees: data.examFees !== undefined ? data.examFees : existingMetadata.examFees,
        vacanciesSeat: data.vacanciesSeat !== undefined ? data.vacanciesSeat : existingMetadata.vacanciesSeat,
        evaluationExamPattern: data.evaluationExamPattern !== undefined ? data.evaluationExamPattern : existingMetadata.evaluationExamPattern,
        cutoff: data.cutoff !== undefined ? data.cutoff : existingMetadata.cutoff,
        eligibility: data.eligibility !== undefined ? data.eligibility : existingMetadata.eligibility,
        ageLimit: data.ageLimit !== undefined ? data.ageLimit : existingMetadata.ageLimit,
        isPublished: data.isPublished !== undefined ? data.isPublished : existingMetadata.isPublished,
      },
    };

    return this.prisma.post.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteGovtVacancy(id: string) {
    const post = await this.prisma.post.findUnique({
      where: { id, postType: 'GOVT_JOB' },
    });

    if (!post) {
      throw new NotFoundException('Government vacancy not found');
    }

    return this.prisma.post.delete({
      where: { id },
    });
  }

  // ========== Jobs Management ==========
  async getJobs(filters?: any) {
    const where: any = {};
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
        { jobDescription: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.status) where.status = filters.status;

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
        _count: { select: { jobApplications: true } },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateJob(id: string, data: any) {
    return this.prisma.jobPost.update({ where: { id }, data });
  }

  // ========== Internships ==========
  async getInternships(filters?: any) {
    const where: any = { jobType: 'INTERNSHIP' };
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== Freelancing ==========
  async getFreelancing(filters?: any) {
    const where: any = { jobType: 'FREELANCE' };
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== College Feeds ==========
  async getCollegeFeeds(filters?: any) {
    const where: any = {};
    if (filters?.collegeId) {
      where.user = { studentProfile: { collegeId: filters.collegeId } };
    }
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: {
        user: { include: { studentProfile: { include: { college: true } } } },
        category: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== Students Community ==========
  async getCommunityPosts(filters?: any) {
    const where: any = {};
    if (filters?.categoryId) where.categoryId = filters.categoryId;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: {
        user: { include: { studentProfile: true } },
        category: true,
        _count: { select: { likes: true, comments: true } },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async moderateCommunityPost(id: string, action: 'approve' | 'reject' | 'delete') {
    if (action === 'delete') {
      return this.prisma.post.update({ where: { id }, data: { isActive: false } });
    }
    return this.prisma.post.update({ where: { id }, data: { isActive: action === 'approve' } });
  }

  // ========== Feed Management ==========
  async getFeeds(filters?: any) {
    const where: any = {};
    if (filters?.postType) where.postType = filters.postType;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.isActive !== undefined) where.isActive = filters.isActive === 'true';

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async updateFeed(id: string, data: any) {
    return this.prisma.post.update({ where: { id }, data });
  }

  async deleteFeed(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== User Management ==========
  async getUsers(filters?: any) {
    const where: any = {};
    if (filters?.userType) where.userType = filters.userType;
    if (filters?.search) {
      where.OR = [
        { email: { contains: filters.search, mode: 'insensitive' } },
        { mobile: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.user.findMany({
      where,
      include: {
        studentProfile: true,
        companyProfile: true,
        collegeProfile: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateUser(id: string, data: any) {
    return this.prisma.user.update({ where: { id }, data });
  }

  // ========== Institute Management ==========
  async getInstitutes(filters?: any) {
    const where: any = {};
    if (filters?.search) {
      where.OR = [
        { name: { contains: filters.search, mode: 'insensitive' } },
        { city: { contains: filters.search, mode: 'insensitive' } },
        { state: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.isActive !== undefined) where.isActive = filters.isActive === 'true';

    return this.prisma.college.findMany({
      where,
      include: {
        _count: {
          select: {
            students: true,
            courses: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    });
  }

  async createInstitute(data: any) {
    return this.prisma.college.create({ data });
  }

  async updateInstitute(id: string, data: any) {
    return this.prisma.college.update({ where: { id }, data });
  }

  async deleteInstitute(id: string) {
    // Check if institute has students
    const studentCount = await this.prisma.studentProfile.count({
      where: { collegeId: id },
    });

    if (studentCount > 0) {
      throw new ConflictException(`Cannot delete institute: it has ${studentCount} student(s) tagged with it. Please delete or reassign the students first.`);
    }

    return this.prisma.college.update({ where: { id }, data: { isActive: false } });
  }

  // ========== Course Master Data ==========
  async getCourseMasterData() {
    return this.prisma.courseCategory.findMany({
      include: {
        _count: { select: { courses: true } },
      },
      orderBy: { name: 'asc' },
    });
  }

  async createCourseCategory(data: any) {
    return this.prisma.courseCategory.create({ data });
  }

  async updateCourseCategory(id: string, data: any) {
    return this.prisma.courseCategory.update({ where: { id }, data });
  }

  async getCoursesByInstitute(instituteId: string) {
    return this.prisma.course.findMany({
      where: { collegeId: instituteId },
      include: { category: true },
      orderBy: { name: 'asc' },
    });
  }

  async createCourse(data: any) {
    return this.prisma.course.create({ data });
  }

  async updateCourse(id: string, data: any) {
    return this.prisma.course.update({ where: { id }, data });
  }

  // ========== Wall Categories ==========
  async getWallCategories(filters?: { parentId?: string; categoryFor?: string; onlyParents?: boolean }) {
    try {
      const where: any = {
        isActive: true,
      };

      // Filter by parentId if provided (for getting subcategories)
      if (filters?.parentId) {
        where.parentCategoryId = filters.parentId;
      } else if (filters?.onlyParents !== false) {
        // Default: only return parent categories (where parentCategoryId is null)
        where.parentCategoryId = null;
      }
      // If onlyParents is explicitly false and no parentId, return all categories

      // Filter by categoryFor if provided
      if (filters?.categoryFor) {
        where.categoryFor = filters.categoryFor;
      }

      const categories = await this.prisma.wallCategory.findMany({
        where,
        orderBy: { name: 'asc' },
      });

      // Get post counts for all categories
      const categoriesWithCounts = await Promise.all(
        categories.map(async (cat) => {
          const postCount = await this.prisma.post.count({
            where: { categoryId: cat.id, isActive: true },
          });

          return {
            id: cat.id,
            name: cat.name,
            description: cat.description,
            isActive: cat.isActive,
            parentCategoryId: cat.parentCategoryId, // Include parentCategoryId in response
            postCount,
            createdAt: cat.createdAt,
            updatedAt: cat.updatedAt,
          };
        })
      );

      this.logger.log(`Found ${categoriesWithCounts.length} categories (parentId: ${filters?.parentId || 'none'}, onlyParents: ${filters?.onlyParents !== false})`);

      return categoriesWithCounts;
    } catch (error: any) {
      this.logger.error('Error fetching wall categories:', error);
      throw new BadRequestException(`Failed to fetch wall categories: ${error.message}`);
    }
  }

  async createWallCategory(data: any) {
    // Validate parent category if parentCategoryId is provided
    if (data.parentCategoryId) {
      const parentCategory = await this.prisma.wallCategory.findUnique({
        where: { id: data.parentCategoryId },
      });
      if (!parentCategory) {
        throw new BadRequestException('Parent category not found');
      }
      // Ensure parent is actually a parent (not a sub-category)
      if (parentCategory.parentCategoryId !== null && parentCategory.parentCategoryId !== undefined) {
        throw new BadRequestException('Cannot create sub-categories under a sub-category. Maximum depth is 2 levels: parent → sub-category.');
      }
    }

    const category = await this.prisma.wallCategory.create({
      data: {
        name: data.name,
        description: data.description,
        categoryFor: data.categoryFor || null,
        parentCategoryId: data.parentCategoryId !== undefined ? data.parentCategoryId : null,
        isActive: data.isActive !== undefined ? data.isActive : true,
      },
    });

    const postCount = await this.prisma.post.count({
      where: { categoryId: category.id, isActive: true },
    });

    // Get sub-category count if this is a parent category
    const subCategoryCount = data.parentCategoryId === null || data.parentCategoryId === undefined
      ? await this.prisma.wallCategory.count({
          where: { parentCategoryId: category.id },
        })
      : 0;

    return {
      id: category.id,
      name: category.name,
      description: category.description,
      categoryFor: category.categoryFor,
      parentCategoryId: category.parentCategoryId,
      isActive: category.isActive,
      postCount,
      subCategoryCount,
      createdAt: category.createdAt,
      updatedAt: category.updatedAt,
    };
  }

  async updateWallCategory(id: string, data: any) {
    const existing = await this.prisma.wallCategory.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException('Category not found');
    }

    const updated = await this.prisma.wallCategory.update({
      where: { id },
      data: {
        name: data.name,
        description: data.description,
        isActive: data.isActive !== undefined ? data.isActive : existing.isActive,
      },
    });

    const postCount = await this.prisma.post.count({
      where: { categoryId: updated.id, isActive: true },
    });

    return {
      id: updated.id,
      name: updated.name,
      description: updated.description,
      isActive: updated.isActive,
      postCount,
      createdAt: updated.createdAt,
      updatedAt: updated.updatedAt,
    };
  }

  async deleteWallCategory(id: string) {
    const category = await this.prisma.wallCategory.findUnique({
      where: { id },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    // Check if category has posts (which might have constraints preventing deletion)
    const postCount = await this.prisma.post.count({
      where: { categoryId: id },
    });
    
    if (postCount > 0) {
      // Check if any posts have related data that might prevent deletion
      const postsWithJobPost = await this.prisma.post.count({
        where: {
          categoryId: id,
          jobPost: { isNot: null },
        },
      });
      
      if (postsWithJobPost > 0) {
        throw new BadRequestException(
          `Cannot delete category: This category has ${postCount} post(s), including ${postsWithJobPost} job post(s). ` +
          `Job posts cannot be deleted through category deletion. Please delete or reassign the posts first.`
        );
      }
    }

    // Use transaction to ensure atomicity of cascading deletes
    // Using deleteMany for better performance and to avoid transaction timeout issues
    try {
      return await this.prisma.$transaction(async (tx) => {
        let deletedCounts = {
          subcategories: 0,
          chapters: 0,
          posts: 0,
          mcqQuestions: 0,
        };

        // If this is a parent category, delete all subcategories first
        if (!category.parentCategoryId) {
          const subCategories = await tx.wallCategory.findMany({
            where: { parentCategoryId: id },
            select: { id: true },
          });

          const subCategoryIds = subCategories.map(sc => sc.id);
          deletedCounts.subcategories = subCategoryIds.length;

          if (subCategoryIds.length > 0) {
            // Delete chapters for all subcategories (batch delete)
            try {
              const chapterResult = await (tx as any).chapter.deleteMany({
                where: { subCategoryId: { in: subCategoryIds } },
              });
              deletedCounts.chapters = chapterResult.count || 0;
            } catch (error: any) {
              // Chapter table might not exist, ignore
              this.logger.warn(`Could not delete chapters: ${error.message}`);
            }

            // Delete posts for all subcategories (batch delete)
            // Note: JobPost, ExamPost, QuizPost have onDelete: Cascade, so they'll be deleted automatically
            const postsResult = await tx.post.deleteMany({
              where: { categoryId: { in: subCategoryIds } },
            });
            deletedCounts.posts = postsResult.count || 0;

            // Delete MCQ questions for all subcategories (batch delete)
            const mcqResult = await tx.mcqQuestion.deleteMany({
              where: { categoryId: { in: subCategoryIds } },
            });
            deletedCounts.mcqQuestions = mcqResult.count || 0;

            // Delete all subcategories (batch delete)
            await tx.wallCategory.deleteMany({
              where: { id: { in: subCategoryIds } },
            });
          }
        } else {
          // This is a subcategory, delete its chapters
          try {
            const chapterResult = await (tx as any).chapter.deleteMany({
              where: { subCategoryId: id },
            });
            deletedCounts.chapters = chapterResult.count || 0;
          } catch (error: any) {
            // Chapter table might not exist, ignore
            this.logger.warn(`Could not delete chapters: ${error.message}`);
          }
        }

        // Delete posts directly associated with this category (batch delete)
        // Note: JobPost, ExamPost, QuizPost have onDelete: Cascade, so they'll be deleted automatically
        const categoryPostsResult = await tx.post.deleteMany({
          where: { categoryId: id },
        });
        deletedCounts.posts += categoryPostsResult.count || 0;

        // Delete MCQ questions directly associated with this category (batch delete)
        const categoryMcqResult = await tx.mcqQuestion.deleteMany({
          where: { categoryId: id },
        });
        deletedCounts.mcqQuestions += categoryMcqResult.count || 0;

        // Finally, delete the category itself
        await tx.wallCategory.delete({ where: { id } });

        const messageParts = [];
        if (deletedCounts.subcategories > 0) {
          messageParts.push(`${deletedCounts.subcategories} sub-categorie(s)`);
        }
        if (deletedCounts.chapters > 0) {
          messageParts.push(`${deletedCounts.chapters} chapter(s)`);
        }
        if (deletedCounts.posts > 0) {
          messageParts.push(`${deletedCounts.posts} post(s)`);
        }
        if (deletedCounts.mcqQuestions > 0) {
          messageParts.push(`${deletedCounts.mcqQuestions} MCQ question(s)`);
        }

        const message = messageParts.length > 0
          ? `Category deleted successfully. Also deleted: ${messageParts.join(', ')}.`
          : 'Category deleted successfully.';

        return {
          success: true,
          message,
          deleted: deletedCounts,
        };
      }, {
        timeout: 60000, // 60 second timeout for large deletions
        maxWait: 10000, // Maximum time to wait for a transaction slot
      });
    } catch (error: any) {
      this.logger.error(`Error deleting wall category ${id}: ${error.message}`, error.stack);
      
      // Handle Prisma errors
      if (error.code === 'P2003') {
        throw new BadRequestException(
          'Cannot delete category: This category has related data that prevents deletion. ' +
          'Please remove all posts, subcategories, and related content first.'
        );
      }
      
      // Handle transaction timeout
      if (error.code === 'P2034') {
        throw new BadRequestException(
          'Deletion timed out. The category may have too many related records. ' +
          'Please try again or contact support.'
        );
      }
      
      // Re-throw known exceptions
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }
      
      // Generic error
      throw new InternalServerErrorException(
        `Failed to delete category: ${error.message || 'Unknown error occurred'}`
      );
    }
  }

  // ========== Chapters ==========
  async getChapters(filters?: { subCategoryId?: string; isActive?: boolean }) {
    try {
      const where: any = {};
      if (filters?.subCategoryId) where.subCategoryId = filters.subCategoryId;
      if (filters?.isActive !== undefined) {
        where.isActive = filters.isActive;
      } else {
        where.isActive = true; // Default: only show active chapters
      }

      const chapters = await this.prisma.chapter.findMany({
        where,
        include: { subCategory: true },
        orderBy: [
          { order: 'asc' },
          { name: 'asc' },
        ],
      });

      return chapters;
    } catch (error: any) {
      this.logger.error(`Error fetching chapters: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to fetch chapters: ${error.message}`);
    }
  }

  async getChapterById(id: string) {
    try {
      const chapter = await this.prisma.chapter.findUnique({
        where: { id },
        include: { subCategory: true },
      });

      if (!chapter) {
        throw new NotFoundException(`Chapter with ID ${id} not found`);
      }

      return chapter;
    } catch (error: any) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Error fetching chapter ${id}: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to fetch chapter: ${error.message}`);
    }
  }

  async createChapter(data: any) {
    try {
      // Verify subcategory exists
      const subCategory = await this.prisma.wallCategory.findUnique({
        where: { id: data.subCategoryId },
      });

      if (!subCategory) {
        throw new NotFoundException(`Subcategory with ID ${data.subCategoryId} not found`);
      }

      const chapter = await this.prisma.chapter.create({
        data: {
          name: data.name,
          description: data.description,
          subCategoryId: data.subCategoryId,
          order: data.order ?? 0,
          isActive: data.isActive !== undefined ? data.isActive : true,
          metadata: data.metadata || {},
        },
        include: { subCategory: true },
      });

      this.logger.log(`Chapter created: ${chapter.id} - ${chapter.name}`);
      return chapter;
    } catch (error: any) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Error creating chapter: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to create chapter: ${error.message}`);
    }
  }

  async updateChapter(id: string, data: any) {
    try {
      // Verify chapter exists
      const existingChapter = await this.prisma.chapter.findUnique({
        where: { id },
      });

      if (!existingChapter) {
        throw new NotFoundException(`Chapter with ID ${id} not found`);
      }

      // If subCategoryId is being updated, verify it exists
      if (data.subCategoryId && data.subCategoryId !== existingChapter.subCategoryId) {
        const subCategory = await this.prisma.wallCategory.findUnique({
          where: { id: data.subCategoryId },
        });

        if (!subCategory) {
          throw new NotFoundException(`Subcategory with ID ${data.subCategoryId} not found`);
        }
      }

      const chapter = await this.prisma.chapter.update({
        where: { id },
        data: {
          name: data.name,
          description: data.description,
          subCategoryId: data.subCategoryId,
          order: data.order,
          isActive: data.isActive,
          metadata: data.metadata,
        },
        include: { subCategory: true },
      });

      this.logger.log(`Chapter updated: ${chapter.id} - ${chapter.name}`);
      return chapter;
    } catch (error: any) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Error updating chapter ${id}: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to update chapter: ${error.message}`);
    }
  }

  async deleteChapter(id: string) {
    try {
      const chapter = await this.prisma.chapter.findUnique({
        where: { id },
      });

      if (!chapter) {
        throw new NotFoundException(`Chapter with ID ${id} not found`);
      }

      // Check if chapter has articles (Posts with chapterId in metadata)
      const articlesWithChapter = await this.prisma.post.findMany({
        where: {
          isActive: true,
        },
        select: {
          id: true,
          metadata: true,
        },
      });

      // Filter posts that have chapterId in metadata matching this chapter
      const articlesCount = articlesWithChapter.filter((post) => {
        const metadata = post.metadata as any;
        return metadata?.chapterId === id;
      }).length;

      if (articlesCount > 0) {
        throw new ConflictException(`Cannot delete chapter: it has ${articlesCount} article(s) tagged with it. Please delete or reassign the articles first.`);
      }

      await this.prisma.chapter.delete({
        where: { id },
      });

      this.logger.log(`Chapter deleted: ${id} - ${chapter.name}`);
      return { success: true, message: 'Chapter deleted successfully' };
    } catch (error: any) {
      if (error instanceof NotFoundException || error instanceof ConflictException) {
        throw error;
      }
      this.logger.error(`Error deleting chapter ${id}: ${error.message}`, error.stack);
      throw new BadRequestException(`Failed to delete chapter: ${error.message}`);
    }
  }
}
