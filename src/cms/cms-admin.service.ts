import { Injectable, BadRequestException, NotFoundException, ConflictException } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';
import { countWords, countPlainTextCharacters } from '../common/utils/validation.helpers';
import { updateCategoryPostCount } from '../common/utils/category.helpers';
import { Prisma } from '@prisma/client';

@Injectable()
export class CmsAdminService {
  constructor(private prisma: PrismaService) {}

  // ========== Current Affairs & General Knowledge ==========
  async getCurrentAffairs(filters?: any) {
    const where: any = { postType: 'CURRENT_AFFAIRS' };
    if (filters?.category) where.categoryId = filters.category;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    // Default to showing only active posts unless explicitly filtered
    if (filters?.isActive !== undefined) {
      where.isActive = filters.isActive === 'true';
    } else {
      where.isActive = true; // Default: only show active (non-deleted) posts
    }

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async createCurrentAffair(data: any, userId: string) {
    // Validate description word count (max 60 words) - HTML tags are stripped automatically
    if (data.description) {
      const wordCount = countWords(data.description);
      if (wordCount > 60) {
        throw new BadRequestException('Description must be 60 words or less (HTML tags are not counted)');
      }
    }

    // Set isActive based on isPublished: if published, make it active immediately
    const isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    
    // Create the post with basic fields
    const post = await this.prisma.post.create({
      data: {
        userId,
        title: data.title,
        description: data.description,
        postType: 'CURRENT_AFFAIRS',
        categoryId: data.categoryId,
        images: data.images || [],
        isActive,
        // Store additional fields in metadata
        metadata: {
          language: data.language,
          isPublished: data.isPublished,
          fullArticle: data.fullArticle,
          articleCategory: data.articleCategory,
          subCategoryId: data.subCategoryId,
          subCategory: data.subCategory,
          chapterId: data.chapterId,
          section: data.section,
          country: data.country,
          headline: data.headline,
          quickViewContent: data.quickViewContent,
          targetedKeywords: data.targetedKeywords,
          autoGeneratedKeywords: data.autoGeneratedKeywords,
          articleDate: data.articleDate,
          eventDates: data.eventDates ? JSON.parse(JSON.stringify(data.eventDates)) : [],
          eventYearRange: data.eventYearRange,
          locationLat: data.locationLat,
          locationLong: data.locationLong,
          state: data.state,
          district: data.district,
          city: data.city,
          sendNotification: data.sendNotification,
          notificationTime: data.notificationTime,
          articleType: data.articleType,
        },
      },
    });

    return post;
  }

  async getCurrentAffairById(id: string) {
    const post = await this.prisma.post.findUnique({
      where: { id, postType: 'CURRENT_AFFAIRS' },
      include: { 
        user: true, 
        category: true,
      },
    });

    if (!post) {
      throw new NotFoundException('Current affair not found');
    }

    // Return post with metadata fields extracted
    const metadata = post.metadata as any || {};
    return {
      ...post,
      isPublished: metadata.isPublished !== undefined ? metadata.isPublished : post.isActive,
    };
  }

  async updateCurrentAffair(id: string, data: any) {
    // Validate description word count if provided (max 60 words) - HTML tags are stripped automatically
    if (data.description) {
      const wordCount = countWords(data.description);
      if (wordCount > 60) {
        throw new BadRequestException('Description must be 60 words or less (HTML tags are not counted)');
      }
    }

    // Get existing post to preserve metadata
    const existingPost = await this.prisma.post.findUnique({
      where: { id },
      select: { metadata: true },
    });

    const existingMetadata = (existingPost?.metadata as any) || {};

    // Update isActive based on isPublished if provided
    const updateData: any = {
      title: data.title,
      description: data.description,
      categoryId: data.categoryId,
      images: data.images,
      isActive: data.isActive,
      // Store article fields in metadata
      metadata: {
        ...existingMetadata,
        language: data.language !== undefined ? data.language : existingMetadata.language,
        isPublished: data.isPublished !== undefined ? data.isPublished : existingMetadata.isPublished,
        fullArticle: data.fullArticle !== undefined ? data.fullArticle : existingMetadata.fullArticle,
        articleCategory: data.articleCategory !== undefined ? data.articleCategory : existingMetadata.articleCategory,
        subCategoryId: data.subCategoryId !== undefined ? data.subCategoryId : existingMetadata.subCategoryId,
        subCategory: data.subCategory !== undefined ? data.subCategory : existingMetadata.subCategory,
        chapterId: data.chapterId !== undefined ? data.chapterId : existingMetadata.chapterId,
        section: data.section !== undefined ? data.section : existingMetadata.section,
        country: data.country !== undefined ? data.country : existingMetadata.country,
        headline: data.headline !== undefined ? data.headline : existingMetadata.headline,
        quickViewContent: data.quickViewContent !== undefined ? data.quickViewContent : existingMetadata.quickViewContent,
        targetedKeywords: data.targetedKeywords !== undefined ? data.targetedKeywords : existingMetadata.targetedKeywords,
        autoGeneratedKeywords: data.autoGeneratedKeywords !== undefined ? data.autoGeneratedKeywords : existingMetadata.autoGeneratedKeywords,
        articleDate: data.articleDate !== undefined ? data.articleDate : existingMetadata.articleDate,
        eventDates: data.eventDates !== undefined ? JSON.parse(JSON.stringify(data.eventDates)) : existingMetadata.eventDates,
        eventYearRange: data.eventYearRange !== undefined ? data.eventYearRange : existingMetadata.eventYearRange,
        locationLat: data.locationLat !== undefined ? data.locationLat : existingMetadata.locationLat,
        locationLong: data.locationLong !== undefined ? data.locationLong : existingMetadata.locationLong,
        state: data.state !== undefined ? data.state : existingMetadata.state,
        district: data.district !== undefined ? data.district : existingMetadata.district,
        city: data.city !== undefined ? data.city : existingMetadata.city,
        sendNotification: data.sendNotification !== undefined ? data.sendNotification : existingMetadata.sendNotification,
        notificationTime: data.notificationTime !== undefined ? data.notificationTime : existingMetadata.notificationTime,
        articleType: data.articleType !== undefined ? data.articleType : existingMetadata.articleType,
      },
    };

    // Remove undefined fields
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined) {
        delete updateData[key];
      }
    });

    // Set isActive based on isPublished if provided
    if (data.isPublished !== undefined) {
      updateData.isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    }

    return this.prisma.post.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteCurrentAffair(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== General Knowledge ==========
  async getGeneralKnowledge(filters?: any) {
    const where: any = { 
      postType: 'COLLEGE_FEED',
      // Note: articleType filtering removed - all COLLEGE_FEED posts are returned
      // Filtering by articleType in metadata would require raw SQL
    };
    if (filters?.category) where.categoryId = filters.category;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    // Default to showing only active posts unless explicitly filtered
    if (filters?.isActive !== undefined) {
      where.isActive = filters.isActive === 'true';
    } else {
      where.isActive = true; // Default: only show active (non-deleted) posts
    }

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async getGeneralKnowledgeById(id: string) {
    const post = await this.prisma.post.findFirst({
      where: { 
        id,
        postType: 'COLLEGE_FEED',
        // Note: articleType filtering removed
      },
      include: { 
        user: true, 
        category: true,
      },
    });

    if (!post) {
      throw new NotFoundException('General knowledge article not found');
    }

    // Return post with metadata fields extracted
    const metadata = post.metadata as any || {};
    return {
      ...post,
      isPublished: metadata.isPublished !== undefined ? metadata.isPublished : post.isActive,
    };
  }

  async createGeneralKnowledge(data: any, userId: string) {
    // Validate description word count (max 60 words) - HTML tags are stripped automatically
    if (data.description) {
      const wordCount = countWords(data.description);
      if (wordCount > 60) {
        throw new BadRequestException('Description must be 60 words or less (HTML tags are not counted)');
      }
    }

    // Set isActive based on isPublished: if published, make it active immediately
    const isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    
    // Create the post with basic fields
    const post = await this.prisma.post.create({
      data: {
        userId,
        title: data.title,
        description: data.description,
        postType: 'COLLEGE_FEED',
        categoryId: data.categoryId,
        images: data.images || [],
        isActive,
        // Store additional fields in metadata
        metadata: {
          language: data.language,
          isPublished: data.isPublished,
          fullArticle: data.fullArticle,
          articleCategory: data.articleCategory,
          subCategoryId: data.subCategoryId,
          subCategory: data.subCategory,
          chapterId: data.chapterId,
          section: data.section,
          country: data.country,
          headline: data.headline,
          quickViewContent: data.quickViewContent,
          targetedKeywords: data.targetedKeywords,
          autoGeneratedKeywords: data.autoGeneratedKeywords,
          articleDate: data.articleDate,
          eventDates: data.eventDates ? JSON.parse(JSON.stringify(data.eventDates)) : [],
          eventYearRange: data.eventYearRange,
          locationLat: data.locationLat,
          locationLong: data.locationLong,
          state: data.state,
          district: data.district,
          city: data.city,
          sendNotification: data.sendNotification,
          notificationTime: data.notificationTime,
          articleType: 'GENERAL_KNOWLEDGE', // Set articleType for GK articles
        },
      },
    });

    return post;
  }

  async updateGeneralKnowledge(id: string, data: any) {
    // Validate description word count if provided (max 60 words) - HTML tags are stripped automatically
    if (data.description) {
      const wordCount = countWords(data.description);
      if (wordCount > 60) {
        throw new BadRequestException('Description must be 60 words or less (HTML tags are not counted)');
      }
    }

    // Get existing post to preserve metadata
    const existingPost = await this.prisma.post.findUnique({
      where: { id },
      select: { metadata: true },
    });

    const existingMetadata = (existingPost?.metadata as any) || {};

    // Update isActive based on isPublished if provided
    const updateData: any = {
      title: data.title,
      description: data.description,
      categoryId: data.categoryId,
      images: data.images,
      isActive: data.isActive,
      // Store article fields in metadata
      metadata: {
        ...existingMetadata,
        language: data.language !== undefined ? data.language : existingMetadata.language,
        isPublished: data.isPublished !== undefined ? data.isPublished : existingMetadata.isPublished,
        fullArticle: data.fullArticle !== undefined ? data.fullArticle : existingMetadata.fullArticle,
        articleCategory: data.articleCategory !== undefined ? data.articleCategory : existingMetadata.articleCategory,
        subCategoryId: data.subCategoryId !== undefined ? data.subCategoryId : existingMetadata.subCategoryId,
        subCategory: data.subCategory !== undefined ? data.subCategory : existingMetadata.subCategory,
        chapterId: data.chapterId !== undefined ? data.chapterId : existingMetadata.chapterId,
        section: data.section !== undefined ? data.section : existingMetadata.section,
        country: data.country !== undefined ? data.country : existingMetadata.country,
        headline: data.headline !== undefined ? data.headline : existingMetadata.headline,
        quickViewContent: data.quickViewContent !== undefined ? data.quickViewContent : existingMetadata.quickViewContent,
        targetedKeywords: data.targetedKeywords !== undefined ? data.targetedKeywords : existingMetadata.targetedKeywords,
        autoGeneratedKeywords: data.autoGeneratedKeywords !== undefined ? data.autoGeneratedKeywords : existingMetadata.autoGeneratedKeywords,
        articleDate: data.articleDate !== undefined ? data.articleDate : existingMetadata.articleDate,
        eventDates: data.eventDates !== undefined ? JSON.parse(JSON.stringify(data.eventDates)) : existingMetadata.eventDates,
        eventYearRange: data.eventYearRange !== undefined ? data.eventYearRange : existingMetadata.eventYearRange,
        locationLat: data.locationLat !== undefined ? data.locationLat : existingMetadata.locationLat,
        locationLong: data.locationLong !== undefined ? data.locationLong : existingMetadata.locationLong,
        state: data.state !== undefined ? data.state : existingMetadata.state,
        district: data.district !== undefined ? data.district : existingMetadata.district,
        city: data.city !== undefined ? data.city : existingMetadata.city,
        sendNotification: data.sendNotification !== undefined ? data.sendNotification : existingMetadata.sendNotification,
        notificationTime: data.notificationTime !== undefined ? data.notificationTime : existingMetadata.notificationTime,
        articleType: data.articleType !== undefined ? data.articleType : (existingMetadata.articleType || 'GENERAL_KNOWLEDGE'),
      },
    };

    // Remove undefined fields
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined) {
        delete updateData[key];
      }
    });

    // Set isActive based on isPublished if provided
    if (data.isPublished !== undefined) {
      updateData.isActive = data.isPublished === true ? true : (data.isActive !== undefined ? data.isActive : true);
    }

    return this.prisma.post.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteGeneralKnowledge(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== MCQ Management ==========
  async getMcqQuestions(filters?: any) {
    const where: any = {};
    if (filters?.categoryId) where.categoryId = filters.categoryId;
    if (filters?.articleId) where.articleId = filters.articleId; // Support filtering by articleId
    if (filters?.search) {
      where.OR = [
        { question: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.mcqQuestion.findMany({
      where,
      include: { category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async createMcqQuestion(data: any) {
    // Validate categoryId is provided (required field)
    if (!data.categoryId) {
      throw new BadRequestException('categoryId is required for MCQ questions');
    }

    // Create MCQ with all fields as columns
    return this.prisma.mcqQuestion.create({
      data: {
        question: data.question,
        options: data.options,
        correctAnswer: data.correctAnswer,
        categoryId: data.categoryId,
        explanation: data.explanation,
        difficulty: data.difficulty || 'medium',
        tags: data.tags || [],
        // articleId and metadata fields removed from schema
        // Store in metadata if needed
        // articleId: data.articleId,
        // mcqCategory: data.mcqCategory,
        // subCategory: data.subCategory,
        // subCategoryId: data.subCategoryId,
        // chapterId: data.chapterId,
        // section: data.section,
        // country: data.country,
        // questionImage: data.questionImage,
        // explanationImage: data.explanationImage,
      },
    });
  }

  async updateMcqQuestion(id: string, data: any) {
    return this.prisma.mcqQuestion.update({ where: { id }, data });
  }

  async deleteMcqQuestion(id: string) {
    return this.prisma.mcqQuestion.delete({ where: { id } });
  }

  async getMcqCategories() {
    // MCQ questions now use WallCategory instead of McqCategory
    // Return wall categories that can be used for MCQ
    return this.prisma.wallCategory.findMany({ 
      where: { isActive: true },
      orderBy: { name: 'asc' } 
    });
  }

  async createMcqCategory(data: any) {
    // MCQ questions now use WallCategory instead of McqCategory
    // Create a wall category for MCQ use
    return this.prisma.wallCategory.create({ 
      data: {
        ...data,
        categoryFor: 'MCQ', // Mark as MCQ category
      }
    });
  }

  // ========== Know Yourself (Personality Quiz) ==========
  async getPersonalityQuestions(filters?: { isPublished?: boolean; includeInactive?: boolean | string }) {
    try {
      // Handle includeInactive parameter (can be boolean or string from query params)
      let includeInactive = false;
      if (filters?.includeInactive !== undefined) {
        if (typeof filters.includeInactive === 'boolean') {
          includeInactive = filters.includeInactive;
        } else if (typeof filters.includeInactive === 'string') {
          includeInactive = filters.includeInactive.toLowerCase() === 'true';
        }
      }
      
      // Build where clause - always include at least isActive filter for consistency
      const where: any = includeInactive ? {} : { isActive: true };
      
      // Note: PersonalityQuiz doesn't have isPublished field
      // If frontend sends isPublished filter, we ignore it
      
      // Execute query with error handling
      let questions;
      try {
        // Try ordering by order field first
        questions = await this.prisma.personalityQuiz.findMany({
          where,
          orderBy: { order: 'asc' },
        });
      } catch (dbError: any) {
        console.error('Database error fetching personality questions (orderBy order failed):', dbError.message, dbError.code);
        // If orderBy fails, try ordering by createdAt instead
        try {
          questions = await this.prisma.personalityQuiz.findMany({
            where,
            orderBy: { createdAt: 'asc' },
          });
          console.log(`Fallback query succeeded: Found ${questions.length} questions (ordered by createdAt)`);
        } catch (fallbackError: any) {
          console.error('Fallback query also failed:', fallbackError.message);
          // Last resort: try without orderBy
          try {
            questions = await this.prisma.personalityQuiz.findMany({
              where,
            });
            console.log(`No-order query succeeded: Found ${questions.length} questions`);
          } catch (noOrderError: any) {
            console.error('No-order query also failed:', noOrderError.message);
            throw dbError; // Throw original error
          }
        }
      }
      
      // Log for debugging
      console.log(`Found ${questions.length} personality quiz questions (includeInactive: ${includeInactive})`);
      
      // Return questions array directly (frontend expects array)
      return questions;
    } catch (error: any) {
      console.error('Error fetching personality quiz questions:', {
        message: error.message,
        code: error.code,
        name: error.name,
        stack: error.stack?.substring(0, 500),
      });
      // Re-throw the original error to preserve status codes
      throw error;
    }
  }

  async createPersonalityQuestion(data: any) {
    // Extract isPublished and set default if not provided
    const { isPublished = false, ...questionData } = data;
    
    return this.prisma.personalityQuiz.create({
      data: {
        ...questionData,
        isPublished,
      },
    });
  }

  async updatePersonalityQuestion(id: string, data: any) {
    // isPublished can be updated along with other fields
    return this.prisma.personalityQuiz.update({ 
      where: { id }, 
      data 
    });
  }

  async deletePersonalityQuestion(id: string) {
    return this.prisma.personalityQuiz.update({ where: { id }, data: { isActive: false } });
  }

  // ========== Daily Digest ==========
  async getDailyDigests(filters?: any) {
    const where: any = { postType: 'DIGEST' };
    if (filters?.date) where.date = new Date(filters.date);
    if (filters?.isPublished !== undefined) where.isPublished = filters.isPublished === 'true';

    return this.prisma.post.findMany({
      where,
      include: { user: true },
      orderBy: { createdAt: 'desc' },
    });
  }

  async createDailyDigest(data: any, userId: string) {
    return this.prisma.post.create({
      data: {
        ...data,
        userId,
        postType: 'DIGEST',
      },
    });
  }

  // ========== College Events ==========
  async getCollegeEvents(filters?: any) {
    const where: any = { postType: 'EVENT' };
    if (filters?.collegeId) where.user = { collegeProfile: { id: filters.collegeId } };
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: { user: { include: { collegeProfile: true } } },
      orderBy: { createdAt: 'desc' },
    });
  }

  async createCollegeEvent(data: any, userId: string) {
    return this.prisma.post.create({
      data: {
        ...data,
        userId,
        postType: 'EVENT',
      },
    });
  }

  // ========== Govt Vacancies ==========
  async getGovtVacancies(filters?: any) {
    const where: any = { postType: 'JOB' };
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== Jobs Management ==========
  async getJobs(filters?: any) {
    const where: any = {};
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
        { jobDescription: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.status) where.status = filters.status;

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
        _count: { select: { jobApplications: true } },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateJob(id: string, data: any) {
    return this.prisma.jobPost.update({ where: { id }, data });
  }

  // ========== Internships ==========
  async getInternships(filters?: any) {
    const where: any = { jobType: 'INTERNSHIP' };
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== Freelancing ==========
  async getFreelancing(filters?: any) {
    const where: any = { jobType: 'FREELANCE' };
    if (filters?.search) {
      where.OR = [
        { jobTitle: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.jobPost.findMany({
      where,
      include: {
        post: { include: { user: true } },
        company: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== College Feeds ==========
  async getCollegeFeeds(filters?: any) {
    const where: any = {};
    if (filters?.collegeId) {
      where.user = { studentProfile: { collegeId: filters.collegeId } };
    }
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: {
        user: { include: { studentProfile: { include: { college: true } } } },
        category: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  // ========== Students Community ==========
  async getCommunityPosts(filters?: any) {
    const where: any = {};
    if (filters?.categoryId) where.categoryId = filters.categoryId;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.post.findMany({
      where,
      include: {
        user: { include: { studentProfile: true } },
        category: true,
        _count: { select: { likes: true, comments: true } },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async moderateCommunityPost(id: string, action: 'approve' | 'reject' | 'delete') {
    if (action === 'delete') {
      return this.prisma.post.update({ where: { id }, data: { isActive: false } });
    }
    return this.prisma.post.update({ where: { id }, data: { isActive: action === 'approve' } });
  }

  // ========== Feed Management ==========
  async getFeeds(filters?: any) {
    const where: any = {};
    if (filters?.postType) where.postType = filters.postType;
    if (filters?.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.isActive !== undefined) where.isActive = filters.isActive === 'true';

    return this.prisma.post.findMany({
      where,
      include: { user: true, category: true },
      orderBy: { createdAt: 'desc' },
      skip: filters?.page ? (parseInt(String(filters.page), 10) - 1) * parseInt(String(filters.limit || 20), 10) : 0,
      take: parseInt(String(filters?.limit || 20), 10),
    });
  }

  async updateFeed(id: string, data: any) {
    return this.prisma.post.update({ where: { id }, data });
  }

  async deleteFeed(id: string) {
    return this.prisma.post.update({ where: { id }, data: { isActive: false } });
  }

  // ========== User Management ==========
  async getUsers(filters?: any) {
    const where: any = {};
    if (filters?.userType) where.userType = filters.userType;
    if (filters?.search) {
      where.OR = [
        { email: { contains: filters.search, mode: 'insensitive' } },
        { mobile: { contains: filters.search, mode: 'insensitive' } },
      ];
    }

    return this.prisma.user.findMany({
      where,
      include: {
        studentProfile: true,
        companyProfile: true,
        collegeProfile: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateUser(id: string, data: any) {
    return this.prisma.user.update({ where: { id }, data });
  }

  // ========== Institute Management ==========
  async getInstitutes(filters?: any) {
    const where: any = {};
    if (filters?.search) {
      where.OR = [
        { name: { contains: filters.search, mode: 'insensitive' } },
        { city: { contains: filters.search, mode: 'insensitive' } },
        { state: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    if (filters?.isActive !== undefined) where.isActive = filters.isActive === 'true';

    return this.prisma.college.findMany({
      where,
      include: {
        _count: {
          select: {
            students: true,
            courses: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    });
  }

  async createInstitute(data: any) {
    return this.prisma.college.create({ data });
  }

  async updateInstitute(id: string, data: any) {
    return this.prisma.college.update({ where: { id }, data });
  }

  async deleteInstitute(id: string) {
    return this.prisma.college.update({ where: { id }, data: { isActive: false } });
  }

  // ========== Course Master Data ==========
  async getCourseMasterData() {
    return this.prisma.courseCategory.findMany({
      include: {
        _count: { select: { courses: true } },
      },
      orderBy: { name: 'asc' },
    });
  }

  async createCourseCategory(data: any) {
    return this.prisma.courseCategory.create({ data });
  }

  async updateCourseCategory(id: string, data: any) {
    return this.prisma.courseCategory.update({ where: { id }, data });
  }

  async getCoursesByInstitute(instituteId: string) {
    return this.prisma.course.findMany({
      where: { collegeId: instituteId },
      include: { category: true },
      orderBy: { name: 'asc' },
    });
  }

  async createCourse(data: any) {
    return this.prisma.course.create({ data });
  }

  async updateCourse(id: string, data: any) {
    return this.prisma.course.update({ where: { id }, data });
  }

  // ========== Wall Categories ==========
  async getWallCategories(filters?: { parentId?: string; categoryFor?: string; onlyParents?: boolean }) {
    try {
      const categories = await this.prisma.wallCategory.findMany({
        where: {
          isActive: true,
        },
        orderBy: { name: 'asc' },
      });

      // Get post counts for all categories
      const categoriesWithCounts = await Promise.all(
        categories.map(async (cat) => {
          const postCount = await this.prisma.post.count({
            where: { categoryId: cat.id, isActive: true },
          });

          return {
            id: cat.id,
            name: cat.name,
            description: cat.description,
            isActive: cat.isActive,
            postCount,
            createdAt: cat.createdAt,
            updatedAt: cat.updatedAt,
          };
        })
      );

      return categoriesWithCounts;
    } catch (error: any) {
      console.error('Error fetching wall categories:', error);
      throw new BadRequestException(`Failed to fetch wall categories: ${error.message}`);
    }
  }

  async createWallCategory(data: any) {
    const category = await this.prisma.wallCategory.create({
      data: {
        name: data.name,
        description: data.description,
        isActive: data.isActive !== undefined ? data.isActive : true,
      },
    });

    const postCount = await this.prisma.post.count({
      where: { categoryId: category.id, isActive: true },
    });

    return {
      id: category.id,
      name: category.name,
      description: category.description,
      isActive: category.isActive,
      postCount,
      createdAt: category.createdAt,
      updatedAt: category.updatedAt,
    };
  }

  async updateWallCategory(id: string, data: any) {
    const existing = await this.prisma.wallCategory.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException('Category not found');
    }

    const updated = await this.prisma.wallCategory.update({
      where: { id },
      data: {
        name: data.name,
        description: data.description,
        isActive: data.isActive !== undefined ? data.isActive : existing.isActive,
      },
    });

    const postCount = await this.prisma.post.count({
      where: { categoryId: updated.id, isActive: true },
    });

    return {
      id: updated.id,
      name: updated.name,
      description: updated.description,
      isActive: updated.isActive,
      postCount,
      createdAt: updated.createdAt,
      updatedAt: updated.updatedAt,
    };
  }

  async deleteWallCategory(id: string) {
    const category = await this.prisma.wallCategory.findUnique({
      where: { id },
    });

    if (!category) {
      throw new NotFoundException('Category not found');
    }

    // Check if category has posts
    const postCount = await this.prisma.post.count({
      where: { categoryId: id, isActive: true },
    });

    if (postCount > 0) {
      throw new ConflictException(`Cannot delete category: it is in use by ${postCount} post(s). Set isActive to false instead.`);
    }

    // Delete the category
    await this.prisma.wallCategory.delete({ where: { id } });

    return {
      success: true,
      message: 'Category deleted successfully',
    };
  }

  // ========== Chapters ==========
  // Note: Chapter model has been removed from schema - these methods are disabled
  async getChapters(filters?: { subCategoryId?: string; isActive?: boolean }) {
    throw new BadRequestException('Chapter functionality is not available in the current schema');
  }

  async getChapterById(id: string) {
    throw new BadRequestException('Chapter functionality is not available in the current schema');
  }

  async createChapter(data: any) {
    throw new BadRequestException('Chapter functionality is not available in the current schema');
  }

  async updateChapter(id: string, data: any) {
    throw new BadRequestException('Chapter functionality is not available in the current schema');
  }

  async deleteChapter(id: string) {
    throw new BadRequestException('Chapter functionality is not available in the current schema');
  }
}
